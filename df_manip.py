import subprocess

"""
Module for manipulating the input and output of dualfoil5.1
"""

# INPUT

def add_new_leg(cu, tt, mc, descr='', path='', 
                restart=True, vcutL=0.0001, vcutH=12.0):
    """
    Appends a new leg to dualfoil's input file,
    which works with or without restart

    Parameters
    ----------
    cu : float
        defines cu(i) for the input
        if mc = 1 or 2, cu is the current
        if mc = 0, cu is the potential
    tt : float
        defines tt(i) for the input
        if mc = 0 or 1, tt is the new leg's duration (min)
        if mc = 2, tt is the cuttof potential (V)
    mc : float
        defines mc(i) for the input, which controls mode of operation
        possible values for dualfoil 5.2 are 0, 1, and 2
    vcutL : float, optional
        Low Voltage cutoff point
    vcutH : float, optional
        High Voltage cutoff point
    descr : str, optional
        comment that describes the function of the new leg
    path : str, optional
        Full or relative path to dualfoil's input file
    restart : bool, optional
        Indicates if simulation will begin from restart data
    """

    newInput = ''
    newLeg = ''
    modified = False
    
    if not path.endswith('/') and len(path) != 0:
        path += '/'
    with open('%sdualfoil5.in' % path, 'r+') as file:

        line = file.readline()
        while line != '':
            if restart:
                # make sure restart is set to true
                if line.find('.false.') != -1:
                    line = line.replace('.false.', '.true.')
            else:
                # make sure restart is set to true
                if line.find('.true.') != -1:
                    line = line.replace('.true.', '.false.')

            # find line before the one we need; set tracker for next loopthru
            if line.find('lcurs') != -1 and not modified:
                tmp = line.lstrip().split()
                # also make sure lcurs is 1
                if int(tmp[0]) != 1:
                    line = line.replace(str(tmp[0]), '1', 1)
                newInput += line

                # skip over all other command lines
                while line != '\n':
                    line = file.readline()
                # if next leg depends on time, we need the total time
                if (mc == 2) or (mc == -1):
                    # depends on cutoff potential; don't alter tt(i)
                    line = (str(cu) + ' ' + str(tt) + ' ' + str(mc) +
                            ' ' + str(vcutL) + ' ' +
                            str(vcutH) + ' !' + descr + '\n\n')
                else:
                    if restart:
                        # depends on time AND we are from restart. need total
                        totT = get_total_time(path)
                        tt += totT
                    line = (str(cu) + ' ' + str(tt) + ' ' + str(mc) +
                            ' ' + str(vcutL) + ' ' +
                            str(vcutH) + ' !' + descr + '\n\n')
                # don't do this again even if 'lcurs' is in file again
                modified = True

            # keep up the new file and read next line
            newInput += line
            line = file.readline()

    with open('%sdualfoil5.in' % path, 'w') as file:
        file.write(newInput)

def get_total_time(path=''):
    """
    Get the total dualfoil simulation time in minutes
    
    Parameters
    ----------
    path : str, optional
        Full or relative path to dualfoil files
    """
    rstFile = open('%sdf_restart.dat' % path, 'r')
    tmp = rstFile.readline()
    tmp = tmp.lstrip().split()
    # get timestep in minutes
    ts = float(tmp[1]) / 60
    return ts
        
# OUTPUT:
# for extracting and organizing data from dualfoil5.out

def extract_main_output(file='dualfoil5.out', path=''):
    """
    Gathers data from dualfoil5.out generated by dualfoil
    
    Parameters
    ----------
    file : str
        main output file (most likely "Dualfoil5.out") generated by Dualfoil5.1
    path : str
        path to get to file, if not in current directory

    Returns
    -------
    time : list of float
        the time in seconds
    n_util, p_util : list of float
        initial stoicheometric parameter for the negative(n) and positive(p) electrolytes
    potential : list of float
        the potential of the cell in volts
    uocp : list of float
        the open-circuit potential in volts
    curr : list of float
        the current in amperes
    temp : list of float
        the temperature in Celcius
    heatgen : list of float
        the generated heat in Watts/m^2
    """

    # first go through and find position where output starts in file
    x = 0
    previous = ''
    if not path.endswith('/') and len(path) != 0:
        path += '/'
    fpath = path + file
    with open(fpath, 'r') as fin:
        data_list = []

        for line in fin.readlines():
            if line.find('(min)') != -1:
                # found it! stop here
                break
            x += 1

    # now read lines again
    with open(fpath, 'r') as fin:

        for line in fin.readlines()[x+2:]:
            # only take lines with convertable data
            if line.find(',') != -1:
                # make sure we are not taking in a copy
                if line != previous:
                    previous = line
                    line = line.rstrip('\n').rstrip(' ').lstrip(' ')
                    data_list.append(line)

    # variable lists for each time
    time = []
    n_util = []
    p_util = []
    potential = []
    uocp = []
    curr = []
    temp = []
    heatgen = []

    for data in data_list:
        tmp = data.split(',')
        for i in tmp:
            i.lstrip(' ')
        time.append(float(tmp[0]))
        n_util.append(float(tmp[1]))
        p_util.append(float(tmp[2]))
        potential.append(float(tmp[3]))
        uocp.append(float(tmp[4]))
        curr.append(float(tmp[5]))
        temp.append(float(tmp[6]))

        # for 5.1 code

        if (tmp[7] == ' ******'):
            tmp[7] = '0.00'
        heatgen.append(float(tmp[7]))

    # return data in order it appears
    return time, n_util, p_util, potential, uocp, curr, temp, heatgen


def extract_profiles(file='profiles.out', path=''):

    """
    Gathers data from profiles.out generated by dualfoil.
    
    Parameters
    ----------
    file : str
        main output file (most likely "Dualfoil5.out") generated by Dualfoil5.2
    path : str
        path to get to file, if not in current directory

    Returns
    -------
    time : list of floats
        the time in seconds each profile is taken
    distance : list of floats
        the distance accross the cell in microns
    elec_conc : list of list of floats
        the concentration of electrolyte in mol/cubic meters
    sol_surf : list of list of floats
        Potential in the electrolyte, neg. or pos. depending on location in cell
    liq_potential : list of list of floats
        the liquid potential in volts
    sol_potential : list of list of floats
        the solid potential in volts
    liq_cur : list of list of floats
        the liquid current density in amperes/square meters
    jmain : list of list of floats
        main liquid current density in amperes/square meters
    jside1 : list of list of floats
        first side reaction liquid current density in amperes/square meters
    jside2 : list of list of floats
        second side reaction liquid current density in amperes/square meters
    jside3 : list of list of floats
        third side reaction liquid current density in amperes/square meters
    """

    if not path.endswith('/') and len(path) != 0:
        path += '/'
    fpath = path + file
    with open(fpath, 'r') as fin:
        profile_list = []
        profile = []

        # ignore the first line
        for line in fin.readlines()[1:]:

            line = line.rstrip('\n').rstrip(' ')
            if line == '':
                if profile != []:
                    profile_list.append(profile)
                    profile = []
                continue
            # print(line)
            profile.append(line)

    # list of appropriate variable lists for each time chunk
    distance_list = []
    elec_conc_list = []
    sol_surf_conc_list = []
    liquid_potential_list = []
    solid_potential_list = []
    liquid_cur_list = []
    j_main_list = []
    j_side1_list = []
    j_side2_list = []
    j_side3_list = []
    time_list = []

    # add each row's data into appropriate list
    for profile in profile_list:
        # extract columns
        distance = []
        elec_conc = []
        sol_surf_conc = []
        liquid_potential = []
        solid_potential = []
        liquid_cur = []
        j_main = []
        j_side1 = []
        j_side2 = []
        j_side3 = []

        for row in profile[3:]:
            tmp = row.split(',')
            distance.append(float(tmp[0]))
            elec_conc.append(float(tmp[1]))
            sol_surf_conc.append(float(tmp[2]))
            liquid_potential.append(float(tmp[3]))
            solid_potential.append(float(tmp[4]))
            liquid_cur.append(float(tmp[5]))
            j_main.append(float(tmp[6]))
            j_side1.append(float(tmp[7]))
            j_side2.append(float(tmp[8]))
            j_side3.append(float(tmp[9]))

        # add each data list to its corresponding vector
        distance_list.append(distance)
        elec_conc_list.append(elec_conc)
        sol_surf_conc_list.append(sol_surf_conc)
        liquid_potential_list.append(liquid_potential)
        solid_potential_list.append(solid_potential)
        liquid_cur_list.append(liquid_cur)
        j_main_list.append(j_main)
        j_side1_list.append(j_side1)
        j_side2_list.append(j_side2)
        j_side3_list.append(j_side3)

        # extract time step and add to time list
        tmp = profile[2]
        time = float(tmp.lstrip('t = ').split(' ')[0])
        time_list.append(time)

    # return data in order it appears
    return (time_list, distance_list, elec_conc_list,
            sol_surf_conc_list, liquid_potential_list,
            solid_potential_list, liquid_cur_list, j_main_list,
            j_side1_list, j_side2_list, j_side3_list)

class OutputManager:
    """
    Maintains the output generated by dualfoil
    
    Attributes
    ----------
    filePath : str
        Full or relative path to dualfoil files
    time : list of float
        the time in seconds
    n_util, p_util : list of float
        initial stoicheometric parameter for the negative(n) and positive(p) electrolytes
    potential : list of float
        the potential of the cell in volts
    uocp : list of float
        the open-circuit potential in volts
    curr : list of float
        the current in amperes
    temp : list of float
        the temperature in Celcius
    heatgen : list of float
        the generated heat in Watts/m^2
    time_prof : list of floats
        the time in seconds each profile is taken
    distance_prof : list of floats
        the distance accross the cell in microns
    elec_conc_prof : list of list of floats
        the concentration of electrolyte in mol/cubic meters
    sol_surf_prof : list of list of floats
        Potential in the electrolyte, neg. or pos. depending on location in cell
    liq_potential_prof : list of list of floats
        the liquid potential in volts
    sol_potential_prof : list of list of floats
        the solid potential in volts
    liq_cur_prof : list of list of floats
        the liquid current density in amperes/square meters
    jmain_prof : list of list of floats
        main liquid current density
    jside1_prof : list of list of floats
        first side reaction liquid current density
    jside2_prof : list of list of floats
        second side reaction liquid current density
    jside3_prof : list of list of floats
        third side reaction liquid current density
    """
    
    def __init__(self, path=''):
        """
        Initialize output list variables.
        
        Parameters
        ----------
        path : string
            Full or relative path to dualfoil files
        """

        if not path.endswith('/') and len(path) != 0:
            path += '/'
        self.filePath = path

        # main output list variables
        self.time = []
        self.n_util = []
        self.p_util = []
        self.potential = []
        self.uocp = []
        self.curr = []
        self.temp = []
        self.heatgen = []
        
        # profile list variables
        self.time_prof = []
        self.distance_prof = []
        self.elec_conc_prof = []
        self.sol_surf_conc_prof = []
        self.liq_pot_prof = []
        self.sol_pot_prof = []
        self.liq_cur_prof = []
        self.jmain_prof = []
        self.jside1_prof = []
        self.jside2_prof = []
        self.jside3_prof = []
        
    def reset(self):
        """
        Clear all output lists.
        """
        self.time.clear()
        self.n_util.clear()
        self.p_util.clear()
        self.potential.clear()
        self.uocp.clear()
        self.curr.clear()
        self.temp.clear()
        self.heatgen.clear()
        self.time_prof.clear()
        self.distance_prof.clear()
        self.elec_conc_prof.clear()
        self.sol_surf_conc_prof.clear()
        self.liq_pot_prof.clear()
        self.sol_pot_prof.clear()
        self.liq_cur_prof.clear()
        self.jmain_prof.clear()
        self.jside1_prof.clear()
        self.jside2_prof.clear()
        self.jside3_prof.clear()
        
    def get_voltage(self):
        """
        Get the voltage, or return -1 if there is no output
        
        Returns
        -------
        float
            the voltage in volts
        """
        if len(self.potential) == 0:
            return -1
        else:
            return self.potential[-1]
        
    def get_current(self):
        """
        Get the current, or return -1 if there is no output
        
        Returns
        -------
            the current in amperes
        """
        if len(self.curr) == 0:
            return -1
        else:
            return self.curr[-1]

    def update_output(self):
        """
        Append output data from `dualfoil5.out` and `profiles.out`
        into the appropriate data list.
        """
        # main output
        x = extract_main_output(path=self.filePath)
        self.time += x[0]
        self.n_util += x[1]
        self.p_util += x[2]
        self.potential += x[3]
        self.uocp += x[4]
        self.curr += x[5]
        self.temp += x[6]
        self.heatgen += x[7]

        # profiles
        x = extract_profiles(path=self.filePath)
        self.time_prof += x[0]
        self.distance_prof = x[1]
        self.elec_conc_prof += x[2]
        self.sol_surf_conc_prof += x[3]
        self.liq_pot_prof += x[4]
        self.sol_pot_prof += x[5]
        self.liq_cur_prof += x[6]
        self.jmain_prof += x[7]
        self.jside1_prof += x[8]
        self.jside2_prof += x[9]
        self.jside3_prof += x[10]

    def write_main_output():
        """
        Organizational tool to display the main output from dualfoil 
        into a readable file: combinedOutput.out
        """

        output = [self.time, self.n_util, self.p_util, self.potential,
                  self.uocp, self.curr, self.temp, self.heatgen]
        subprocess.call('date > %scombinedOutput.out' % self.filePath,
                        shell=True)

        # main output data
        with open('%scombinedOutput.out' % self.filePath, 'a') as outFile:
            outFile.write('\nMain Output data\n\n')
            outFile.write('     Time     N_util   P_util   Potential   Uocp       Curr      Temp    Heatgen\n')
            outFile.write('     (min)      x         y        (v)      (v)       (A/m2)      (C)     (W/m2)\n\n')
            for i in range(len(self.time)):
                for j in range(len(output)):
                    outFile.write(str(output[j][i]).rjust(9))
                    outFile.write(',')
                    if j == (len(output)-1):
                        outFile.write('\n')
    